<html>
<head>
<style>
table {
  table-layout: fixed;
  border-collapse: collapse;
  border: 1px solid black;
}

th, td {
	text-align: center;
	border: 1px solid black;
	padding: 2px 1em;
}

tbody tr:nth-child(even) {
  background-color: #ddd;
}

ul {
	padding: 0;
}

li {
	display: inline-block;
	padding: 0 0.5em;
}

</style>
</head>
<body>

<h1>Your last 100 scores</h1>

<!-- TODO: implement sort by field score and date -->
<table>
<thead>
	<tr>
		<th class="sorter" data-field="datetime">Date</th>
		<th>Start Level</th>
		<th>End Level</th>
		<th class="sorter" data-field="score">Score</th>
		<th>Lines</th>
		<th class="sorter" data-field="tetris_rate">Tetris Rate</th>
		<th>Num Droughts</th>
		<th>Max Drought</th>
		<th>DAS Avg</th>
		<th>Actions</th>
	</tr>
</thead>
<tbody>
	<% scores.forEach(score => { %>
	<tr>
		<td><%= score.datetime.toISOString() %></td>
		<td><%= score.start_level %></td>
		<td><%= score.end_level %></td>
		<td><%= (score.score || 0).toString().padStart(6, '0') %></td>
		<td><%= score.lines %></td>
		<td><%= ((score.tetris_rate || 0) * 100).toFixed(1) %>%</td>
		<td><%= score.num_droughts %></td>
		<td><%= score.max_drought %></td>
		<td><%= (score.das_avg || 0).toFixed(1) %></td>
		<td><a class="delete_score" href="/stats/scores/<%= score.id %>">delete</a></td>
	</tr>
	<% }); %>
</tbody>
</table>

<!-- TODO: implement pagination controls -->
<ul id="pages">
<% for (let page_idx=0; page_idx < num_pages; page_idx++) { %>
	<li>
		<% if (page_idx == pagination.page_idx) { %>
			<%= page_idx + 1 %>
		<% } else { %>
			<a href='#'><%= page_idx + 1 %></a>
		<% } %>
	</li>
<% }; %>
</ul>

<script src="/js/QueryString.js"></script>
<script>
const pagination = <%- JSON.stringify(pagination) %>;

document.querySelectorAll('a.delete_score').forEach(a => {
	a.addEventListener('click', async (evt) => {
		evt.preventDefault();

		try {
			await fetch(a.href, {
				method: 'DELETE',
				mode: 'cors',
				credentials: 'same-origin'
			});
		}
		catch(err) {
			console.log('Unable to delete score');
		}

		location.reload(); // super inefficient, but whatever...
	});
});

const orders = ['desc', 'asc'];

function load() {
	location.href = `${location.pathname}${QueryString._build(pagination)}`;
}

document.querySelectorAll('th.sorter').forEach(th => {
	const a = document.createElement('a');
	a.href = '#';
	a.textContent = th.textContent;
	th.innerHTML = '';

	a.addEventListener('click', evt => {
		evt.preventDefault();

		const field = th.dataset.field;

		if (pagination.sort_field === field) {
			const idx = orders.indexOf(pagination.sort_order);
			pagination.sort_order = orders[(idx + 1) % orders.length];
		}
		else {
			pagination.sort_field = field;
			pagination.sort_order = orders[0];
		}

		pagination.page_idx = 0;
		load();
	});

	th.appendChild(a);
});

document.querySelectorAll('li a').forEach(a => {
	a.addEventListener('click', evt => {
		evt.preventDefault();

		pagination.page_idx = parseInt(a.textContent, 10) - 1;
		load();
	});
});

</script>

</body>
</html>