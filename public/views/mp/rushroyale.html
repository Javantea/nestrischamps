<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="/views/tetris.css" />
		<link rel="stylesheet" type="text/css" href="/views/mmp.css" />
		<style>
			.player {
				top: 341px;
			}

			.no-video .player {
				top: 410px;
			}

			.running_trt {
				height: 79px;
			}

			.timer {
				top: 10px;
				left: 766px;
				width: 340px;
				height: 80px;
				font-size: 24px;
				line-height: 30px;
				padding: 6px 9px 0 9px;
			}

			.timer .header {
				padding-bottom: 12px;
			}

			.timer .value {
				text-align: center;
			}

			@keyframes panic_colorize_wr {
				from {
					color: white;
				}
				to {
					color: red;
				}
			}

			.timer.warn .value {
				animation: panic_colorize_wr 0.5s infinite;
				animation-direction: alternate;
			}

			.timer.panic .value {
				animation: panic_colorize_wr 0.25s infinite;
				animation-direction: alternate;
			}

			.player.eliminated {
				filter: grayscale(1) brightness(0.5);
			}
		</style>
	</head>
	<body>
		<div id="stream_bg">
			<div id="timer" class="box timer">
				<div class="header">ROUND TIMER</div>
				<div class="value"></div>
			</div>

			<div class="box leaderboard">
				<div class="header">RANKING</div>
				<div class="value"></div>
			</div>

			<template id="player">
				<div class="player">
					<div class="box board">
						<div class="lines">000</div>
						<div class="next_piece"></div>
					</div>

					<div class="box score">
						<div class="header">PLAYER</div>
						<div class="value">0000000</div>
					</div>

					<div class="box running_trt"></div>

					<div class="box video"><video class="player_vid"></video></div>
				</div>
			</template>

			<template id="rank">
				<div class="entry">
					<span class="rank">1</span>
					<span class="name">PLAYER</span>
					<span class="score2">0</span>
					<span class="diff">0</span>
				</div>
			</template>
		</div>
		<!-- End Stream BG -->

		<!-- Audio -->
		<script>
			// custom view parameters which will be passed in the websocket URI
			const view_meta = new URLSearchParams({
				video: '352x240',
				players: 8,
			});
		</script>
		<script src="/vendor/peerjs.1.5.4.min.js"></script>
		<script type="module">
			import '/views/bg.js';
			import QueryString from '/js/QueryString.js';
			import Color from '/views/color.js';
			import Gradient from '/views/gradient.js';
			import { peerServerOptions } from '/views/constants.js';
			import { translate, readableScoreFomatter } from '/views/utils.js';
			import Player from '/views/Player.js';
			import Competition from '/views/competition.js';

			const stream_bg = document.getElementById('stream_bg');
			const timer = document.getElementById('timer');
			const rank_template = document.getElementById('rank');
			const player_template = document.getElementById('player');
			const leaderboard_values = document.querySelector('.leaderboard  .value');
			const color_gradient = new Gradient( // green - orange - red
				'#0eff0e',
				new Color(255, 165, 0),
				'#fd0009'
			);

			const players_re = /^[2345678]$/;
			const player_width = 228;
			const players = [];

			let num_players = 8;

			if (players_re.test(QueryString.get('players'))) {
				num_players = parseInt(QueryString.get('players'), 10);
			}

			const cycle_match = (QueryString.get('cycle') || '').match(
				/^[1-9]\d+(,\d+,\d+)?$/
			);
			const cycle_settings = {
				seconds: 30,
				warn: 16,
				panic: 8,
			};

			if (cycle_match) {
				const values = QueryString.get('cycle')
					.split(',')
					.map(v => parseInt(v, 10));
				if (!cycle_match[1]) {
					if (values[0] >= 10) {
						cycle_settings.seconds = values[0];
					}
				} else {
					if (
						values[0] >= 10 &&
						values[0] >= values[1] &&
						values[1] >= values[2]
					) {
						cycle_settings.seconds = values[0];
						cycle_settings.warn = values[1];
						cycle_settings.panic = values[2];
					}
				}
			}

			const spacer = (1920 - num_players * player_width) / (num_players + 1);
			const rank_colors = Array(num_players)
				.fill()
				.map((_, idx) =>
					color_gradient.getColorAt(idx / (num_players - 1)).toHexString()
				);

			function updateScore() {
				const sorted_players = [...players].sort((p1, p2) => {
					const p1_score = p1.getScore();
					const p2_score = p2.getScore();
					return p1_score === p2_score ? p1.idx - p2.idx : p2_score - p1_score;
				});

				sorted_players.forEach((player, idx) => {
					if (!player.game?.over) {
						player.dom.rank_node.style.color = rank_colors[idx];
					}
					player.dom.rank_node.querySelector('.rank').textContent = idx + 1;

					if (idx > 0) {
						const diff = player.getScore() - sorted_players[idx - 1].getScore(); // is always negative!
						player.dom.rank_node.querySelector('.diff').textContent =
							readableScoreFomatter(diff);
					} else {
						player.dom.rank_node.querySelector('.diff').textContent = '';
					}

					leaderboard_values.appendChild(player.dom.rank_node);
				});
			}

			let start_ts;
			let rafId;
			let toId;

			function startRound() {
				start_ts = Date.now();
				checkTime();
				toId = setInterval(kickPlayer, cycle_settings.seconds * 1000);
			}

			function checkTime() {
				const elapsed = Date.now() - start_ts;
				const elapsed_slice = elapsed % (cycle_settings.seconds * 1000);
				const remainder =
					(cycle_settings.seconds * 1000 - elapsed_slice) / 1000;

				let content = remainder.toFixed(2);

				if (remainder < cycle_settings.panic) {
					timer.classList.remove('warn');
					timer.classList.add('panic');
					content = `!! ${content} !!`;
				} else if (remainder < cycle_settings.warn) {
					timer.classList.add('warn');
					content = `! ${content} !`;
				} else {
					timer.classList.remove('warn', 'panic');
				}

				timer.querySelector('.value').textContent = content;

				rafId = window.requestAnimationFrame(checkTime);
			}

			function kickPlayer() {
				const sorted_players = [...players].sort((p1, p2) => {
					const p1_score = p1.getScore();
					const p2_score = p2.getScore();
					return p1_score === p2_score ? p1.idx - p2.idx : p2_score - p1_score;
				});

				const lastPlayer = sorted_players.findLast(
					player => !player.game?.over
				);

				if (lastPlayer) {
					lastPlayer.game?.end();
					lastPlayer.dom.rank_node.style.color = 'grey';
					lastPlayer.dom.full_node.classList.add('eliminated');

					if (sorted_players.indexOf(lastPlayer) <= 1) {
						// there's just one player left, that's the winner
						sorted_players[0].game?.end();
						sorted_players[0].playWinnerAnimation();
						timer.querySelector('.value').textContent = '';
					} else {
						return;
					}
				}

				// round is over, stop all timer
				toId = clearInterval(toId);
				rafId = window.cancelAnimationFrame(rafId);
			}

			window.players = players;
			window.startRound = startRound;

			window.onload = () => {
				// wait for css
				const base_offset_y = 20;

				Array(num_players)
					.fill()
					.forEach((_, player_idx) => {
						const player_fragment = document.importNode(
							player_template.content,
							true
						);
						const player_node = player_fragment.querySelector('.player');

						player_node.classList.add(`p${player_idx + 1}`);
						stream_bg.appendChild(player_node);

						const rank_fragment = document.importNode(
							rank_template.content,
							true
						);
						const rank_node = rank_fragment.querySelector('.entry');

						const player = new Player(
							{
								name: player_node.querySelector(`.score .header`),
								score: player_node.querySelector(`.score .value`),
								lines: player_node.querySelector(`.board .lines`),
								preview: player_node.querySelector(`.board .next_piece`),
								field: player_node.querySelector(`.board`),
								running_trt: player_node.querySelector(`.running_trt`),
								video: player_node.querySelector(`video`),

								full_node: player_node,
								rank_node,
							},
							{
								field_pixel_size: 2.5,
								preview_pixel_size: 2,
								preview_align: 'tr',
								stereo: translate([0, num_players - 1], [-1, 1], player_idx),
								format_score: readableScoreFomatter,
							}
						);

						// adding extra properties to track
						player.idx = player_idx; // For stable sort -_-

						player.__setName = player.setName;
						player.setName = function (name) {
							this.__setName(name);
							this.dom.rank_node.querySelector('.name').textContent =
								name || '';
						};

						player.onGameStart = function () {
							this.dom.lines.hidden = false;
							this.dom.preview.hidden = false;
						};

						player.onGameOver = function () {
							this.dom.lines.hidden = true;
							this.dom.preview.hidden = true;
						};

						player.onGameOver();

						players.push(player);

						Object.assign(player_node.style, {
							left: `${Math.round(
								spacer + player_idx * (player_width + spacer)
							)}px`,
						});

						if (QueryString.get('rtrt') === '0') {
							player.dom.running_trt.remove();
						}
					});

				let cdToId;
				const competition = new Competition(players, {
					startCountDown: function (seconds) {
						cdToId = clearTimeout(cdToId);

						players.forEach(player =>
							player.full_node.classList.remove('eliminated')
						);

						this.__startCountDown(seconds);
						cdToId = setTimeout(startRound, seconds * 1000);
						timer.querySelector('.value').textContent =
							cycle_settings.seconds.toFixed(2);
					},
				});

				players.forEach(player => {
					player.onScore = () => {
						player.dom.rank_node.querySelector('.score2').textContent =
							readableScoreFomatter(player.getScore());
						updateScore();
					};
				});

				if (!competition.has_video) {
					stream_bg.classList.add('no-video');
				}

				window.competition = competition;

				updateScore();
			};

			if (/^\/replay\//.test(location.pathname)) {
				startRound();
			}

			// TODO: hijack countdown API to be a startRound()
		</script>
	</body>
</html>
