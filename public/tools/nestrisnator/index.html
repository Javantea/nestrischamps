<!DOCTYPE html>
<html>
	<head>
		<style>
			#source {
				width: 200px;
				height: 200px;
				background-repeat: no-repeat;
				background-size: cover;
			}

			#work {
			}

			#file_sel_err {
				color: red;
			}
		</style>
	</head>
	<body>
		<p>
			Select an image:
			<input type="file" id="file" name="files" style="display: inline" />
			<span id="file_sel_err" />
		</p>

		<div id="source"></div>
		<div id="work"></div>

		<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
		<script src="/js/QueryString.js"></script>
		<script src="/views/constants.js"></script>
		<script src="/ocr/image_tools.js"></script>
		<script src="/ocr/utils.js"></script>
		<script type="text/javascript">
			let levels = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
			let source_pixel_size = 8;
			let scale = 1;

			if (/^\d(,\d)*$/.test(QueryString.get('levels'))) {
				levels = _.union(QueryString.get('levels').split(',')).map(v => +v);
			}

			if (/^[1-9]|[12][0-9]$/.test(QueryString.get('pixel'))) {
				source_pixel_size = +QueryString.get('pixel');
			}

			if (/^[123456]$/.test(QueryString.get('scale'))) {
				scale = +QueryString.get('scale');
			}

			const dom = {
				file: document.getElementById('file'),
				file_sel_err: document.getElementById('file_sel_err'),
				source: document.getElementById('source'),
				work: document.getElementById('work'),
			};

			let lab_colors;
			let colors;

			/**/
			rgb2lab = function ([r, g, b]) {
				return [r, g, b];
				// return luma(r, g, b);
			};
			/**/

			function renderBlock(color, block_index, pixel_size, ctx, pos_x, pos_y) {
				if (block_index < 1) {
					return;
				}

				switch (block_index) {
					case 0:
					case 1:
						// maybe inefficient because it draws the area twice
						// but drawing the zones will bemore function calls
						// hmmm... check speed and optimize if necessary
						ctx.fillStyle = color;
						ctx.fillRect(pos_x, pos_y, pixel_size * 7, pixel_size * 7);

						/*
						ctx.fillStyle = 'white';
						ctx.fillRect(pos_x, pos_y, pixel_size, pixel_size);

						ctx.fillRect(
							pos_x + pixel_size,
							pos_y + pixel_size,
							pixel_size * 5,
							pixel_size * 5
						);
						/**/

						break;

					case 2:
						ctx.fillStyle = color;
						ctx.fillRect(pos_x, pos_y, pixel_size * 7, pixel_size * 7);

						ctx.fillStyle = 'white';
						ctx.fillRect(pos_x, pos_y, pixel_size, pixel_size);
						ctx.fillRect(
							pos_x + pixel_size,
							pos_y + pixel_size,
							pixel_size * 2,
							pixel_size
						);
						ctx.fillRect(
							pos_x + pixel_size,
							pos_y + pixel_size * 2,
							pixel_size,
							pixel_size
						);
						break;
				}

				ctx.fillStyle = 'black';
				ctx.fillRect(pos_x, pos_y + pixel_size * 7, pixel_size * 7, pixel_size);
				ctx.fillRect(pos_x + pixel_size * 7, pos_y, pixel_size, pixel_size * 8);
			}

			function getColors() {
				const cols = ['#000000', '#FFFFFF'];

				levels.forEach(level => {
					cols.push(...LEVEL_COLORS[level]);
				});

				return _.union(cols);
			}

			function getColorIndex(col_in) {
				col_in = rgb2lab(col_in);

				let min_diff = 0xffffffff;
				let min_idx = -1;

				lab_colors.forEach((col, col_idx) => {
					/**/
					const sum = col.reduce(
						(acc, c, idx) => acc + (c - col_in[idx]) * (c - col_in[idx]),
						0
					);
					/**/

					// const sum = (col - col_in) * (col - col_in);

					if (sum < min_diff) {
						min_diff = sum;
						min_idx = col_idx;
					}
				});

				return min_idx;
			}

			function getColor(col_in) {
				const index = getColorIndex(col_in);

				return colors[index];
			}

			function showError(msg) {
				dom.file_sel_err.textContent = '';
			}

			async function nestrify(img) {
				const width = img.width;
				const height = img.height;

				if (width < source_pixel_size || height < source_pixel_size) {
					showError('Image dimensions are not suitable!');
					return;
				}

				dom.work.innerHTML = '';

				const x_block = Math.floor(width / source_pixel_size);
				const y_block = Math.floor(height / source_pixel_size);
				const x_offset = Math.floor((width - x_block * source_pixel_size) / 2);
				const y_offset = Math.floor((height - y_block * source_pixel_size) / 2);

				const source = document.createElement('canvas');

				source.width = x_block;
				source.height = y_block;

				const source_context = source.getContext('2d', { alpha: false });

				source_context.imageSmoothingEnabled = true;
				source_context.imageSmoothingQuality = 'high';

				dom.work.appendChild(source);

				source_context.drawImage(
					img,
					x_offset,
					y_offset,
					x_block * source_pixel_size,
					y_block * source_pixel_size,
					0,
					0,
					x_block,
					y_block
				);

				// ==========

				const target = document.createElement('canvas');

				target.width = x_block * 8 * scale;
				target.height = y_block * 8 * scale;

				let context;

				context = target.getContext('2d', { alpha: false });

				context.imageSmoothingEnabled = false;

				dom.work.appendChild(target);

				context.drawImage(
					source,
					0,
					0,
					x_block,
					y_block,
					0,
					0,
					x_block * 8 * scale,
					y_block * 8 * scale
				);

				// ==========

				const pixels = source_context.getImageData(0, 0, x_block, y_block);

				const drawn = document.createElement('canvas');

				drawn.width = x_block * 8 * scale;
				drawn.height = y_block * 8 * scale;

				context = drawn.getContext('2d', { alpha: false });

				context.imageSmoothingEnabled = false;

				dom.work.appendChild(drawn);

				for (let ridx = 0; ridx < y_block; ridx++) {
					for (let cidx = 0; cidx < x_block; cidx++) {
						const offset = (ridx * x_block + cidx) * 4; // 4 color channels per pixel
						const col = pixels.data.subarray(offset, offset + 3);
						const block_color = getColor(col);
						const block_type =
							block_color === '#000000' ? 0 : block_color === '#FFFFFF' ? 1 : 2;

						renderBlock(
							block_color,
							block_type,
							scale,
							context,
							cidx * scale * 8,
							ridx * scale * 8
						);
					}
				}
			}

			(async function () {
				function selectImage(evt) {
					showError('');

					if (!(evt && evt.target && evt.target.files && evt.target.files[0]))
						return;

					var selectedFile = evt.target.files[0];
					if (!selectedFile.type.match(/^image\//)) {
						showError('Not an image!');
						return;
					}

					file_name = selectedFile.name;

					var reader = new FileReader();

					reader.onload = function (e) {
						dom.source.style.backgroundImage = `url(${e.target.result})`;

						const img = new Image();
						img.onload = function () {
							nestrify(this);
						};
						img.src = e.target.result;
					};

					reader.readAsDataURL(selectedFile);
				}

				function bootstrap() {
					colors = getColors();
					lab_colors = colors
						.map(col => parseInt(col.slice(1), 16))
						.map(col => [
							(col >> 16) & 0xff,
							(col >> 8) & 0xff,
							(col >> 0) & 0xff,
						])
						.map(rgb2lab);

					file.addEventListener('change', selectImage);
				}

				bootstrap();
			})();
		</script>
	</body>
</html>
